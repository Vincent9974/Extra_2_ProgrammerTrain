​	C语言是嵌入式开发所必需的编程技术，因此在招聘嵌入式系统程序员时，它是一种非常有效的方式。笔者参加过许多相关的测试，并发现这些测试能为应试者与面试者提供许多有用的信息。虽然在应试的过程中会有一些压力，但是这些测试本身也十分有趣。
​	对于应试者来说，可以通过测试题了解出题者的一些情况。例如出题者是擅长微机还是嵌入式系统。对于面试者来说，一个测试题能从多个方面反映应试者的素质，最基本的是C语言编程的水平。如果应试者不会这道测试题，那么他采取的回答方式可以反映出他的一些基本素质。他是找各种借口呢，还是表现出学习的好奇心?这些信息往往与应试者的测试成绩一样有用。本章列出了一些针对嵌入式系统的面试题，希望能给正在找工作的人一些帮助。



# 1. 位制转换

写出下面代码的输出结果。

考点:使用printf输出不同类型的变量

出现频率:★★★★

```cpp
void ex_1()
{
    int i = 5.0; // 修改为整数
    float f = 5;
    printf("%f\n", 5);   // 修改为%f
    printf("%1f\n", 5.01);  // 修改为%f
    printf("%f\n", f);     // 修改为%f

    printf("%d\n", 5.01);  // 修改为%d
    printf("%d\n", i);     // 修改为%d
}
```

​	32位平台中 int和 float都占4个字节，double占8个字节。以下的讨论都是基于32位平台的。
printf根据说明符“%f”，认为参数应该是个double类型的参数(在printf 函数中，float会自动转换成double)，因此从栈中读了8个字节。类似地，当printf后的说明符为"%d"时，会认为参数应该是个int类型的参数，因此从栈中读了4个字节。
​	代码第8行，首先参数5为 int型，所以在栈中分配了4个字节的内存用于存放参数5。然后printf从栈中读8个字节。很显然，内存访问越界，会有不可预料的情况发生。
​	代码第9行和第10行，参数5.0l和f分别是 double类型和 float类型（注意，这里f在赋值时已经做了一次 int到 float 的转化)，而float和 double都是浮点类型，其相互转化是相对安全的，因此这两段代码输出都是5.000000。
​	代码段printf("%dn"，5.0l);，参数5.0l占8个字节，而printf读4个字节，同样会出现不可预料的情况。
​	代码段printf("%dn", i);，参数i是由5.01转换过来的，这里的转换不同于printf中的读取，在数据大小允许的范围之内（没有溢出)，转换是安全的。转换的结果是i等于5，占4个字节，因此这段代码输出为5。
​	从上述分析中可以看出，如果在 printf或者scanf中指定了"%f"，那么后面对应的参数列表也应该是浮点数，或者是一个指向浮点变量的指针，否则就不应该加载支持浮点数的

输出:

```bash
0.000000
5.010000
5.000000
1889785610
5
```



# 2. 看代码写出结果——位运算

考点:使用位操作符>>和<<

出现频率:★★★★

```cpp
void ex_2()
{
    unsigned short int i = 0;
    unsigned char ii = 255;
    int j = 8, p, q;
    p = j << 1;
    q = j >> 1;
    i = i - 1;
    ii = ii + 1;

    printf("i = %d\n", i);
    printf("ii = %d\n", ii);
    printf("p = %d\n", p);
    printf("q = %d\n", q);
}
```

​	本题有两个考点:一是无符号结果的问题;二是用移位的方式代替乘除法。

​	变量i是一个unsigned short int类型，在32位平台下大小是2个字节，因此其无符号类型的大小范围为0～65 535。i赋值之后为0，内存中的数据为0x0000。当执行了i=i- 1;之后，内存中的数据变为0XfMf，所以结果就是65 535。

​	变量i是一个unsigned short char类型，大小是1个字节，因此其无符号类型的大小范围为0～255。ii赋值之后为255，内存中的数据为0xff。当执行了ii = ii + 1;之后，内存中的数据变为0X00，所以结果就是0。

​	左移操作<<相当于乘法操作，<<n相当于乘以2n。右移操作>>相当于除法操作，>>n相当于除以2n。因此，对于变量p和q的输出分别是16和4。

​	通过以上分析可以看出，对于无符号结果的问题，我们需要十分清楚数据在内存中的大小以及其表达形式。另外，我们需要知道移位操作是最有效率的(可以代替乘除法)，因此在嵌入式系统编程或者其他许多需要高效率的地方能够得到运用。

结果:

```bash
i = 65535
ii = 0
p = 16
q = 4
```



# 3. 设置或清除特定的位

考点:使用位操作符&和|

出现频率:★★★★

​	嵌入式系统总是要求用户对变量或寄存器进行位操作。给定一个整型变量a，写两段代码，第一个设置a的 bit 3，第二个清除a的bit 3。在以上两个操作中，要保持其他位不变。

​	通常情况下，应试者对这个问题有3种基本的反应:

(1）不知道如何下手。该被面试者从没做过任何嵌入式系统的工作。

(2）用bit fields。bit fields是被扔到C语言死角的东西，它保证你的代码在不同编译器之间是不可移植的，同时也保证了你的代码是不可重用的。

(3）用#defines 和 bit masks操作。这是一个有极高可移植性的方法，是应该被用到的方法。
最佳的解决方案为:

```cpp
#define BIT3 (0x1 << 3)
static int a;
void ex_3()
{
    a |= BIT3;
    a &= ~BIT3;
}void ex_3()
{
    a |= BIT3;  //设置
    a &= ~BIT3; //取反
}
```

​	在这里，BIT3用来计算需要操作的位，=和&=分别用来指定位置1和位置0。



# 4. 计算一个字节里有多少bit被置1

考点:各种位操作符的使用

出现频率:★★★

```cpp
#define BIT7 (0x1 << 7)
int calculate(unsigned char c)
{
    int count = 0;
    unsigned char comp = BIT7;

    for(int i = 0; i < sizeof(unsigned char) * 8; ++i)
    {
        if((comp & c) != 0)
        {
            count ++;
        }
        comp = comp >> 1;
    }
    return count;
}

void ex_4()
{
    unsigned char c = 1;
    int count = 0;
    printf("Enter a value for c: ");
    scanf("%hhu", &c); // 使用 %hhu 读取无符号字符
    count = calculate(c);
    printf("The number of set bits in c is: %d\n", count);
}
```

​	一个字节(byte)有8位，因此首先在宏定义BIT7中将最高位置成1。然后在calculate函数中比较每个位是否被置成1，如果是，则为count++，循环结束后返回count的值。最后在 main函数中进行测试:如果输入的值为97（二进制为1100001)，则最后打印出count= 3。



# 5. 位运算改错

考点:正确使用位运算符和逻辑运算符

出现频率:★★★

```cpp
#define BIT_MASK(bit_pos) (0x01 << (bit_pos))

int Bit_Reset(unsigned int *val, unsigned char pos) {
    if (pos >= sizeof(unsigned int) * 8) {
        return 0;
    }
    *val = (*val) & (~BIT_MASK(pos));
    return 1;
}

```

​	Bit_Reset函数的作用是要把相应的位置0。首先是位掩码BIT_MASK(bit_ pos)的定义，它的需要置0的位是1，其他位都是0。然后在Bit_Reset 函数中判断pos，如果超出整型的字节范围，则表示返回0失败。最后调用val =(val && ～BIT_MASK(pos));，代码段将val的pos位置0。
​	这里存在位运算的问题。在最后的置0操作中用的是"&&"操作符，它表示的是“逻辑与”，其结果为只要val不为0，调用完第10行代码之后val都变成1，否则便为0。这与设计函数的初衷不符，应该将"&&"替换为"&&"。



# 6. 运用位运算交换a、b 两数

```cpp
void swap(int &a, int &b) {
    // 将 a 和 b 的值进行异或运算，结果存储到 a 中
    a = a ^ b;
    // 将 a 和 b 的值进行异或运算，结果存储到 b 中
    b = a ^ b;
    // 将 a 和 b 的值进行异或运算，结果存储到 a 中
    a = a ^ b;
}

int main() {
    int a = 3;
    int b = 5;
    
    printf("Before swapping: a = %d, b = %d\n", a, b);
    
    swap(a, b);
    
    printf("After swapping: a = %d, b = %d\n", a, b);
    
    return 0;
}
```

​	^是位异或的运算符，即比较相同两位的异同，如果相同，则赋值为0，否则为1。此例中a、b的初始值分别为3和5，对应的二进制分别为00000011和00000101。经过下面的3个步骤交换了两个变量的值。

​	代码第8行，a的二进制变为00000110，b 仍为 00000101。即 b不变，取出所有不相等的位存入a。
​	代码第9行，a的二进制为00000110，b变为00000011。即 a不变，取出所有不相等的位存入b。此时b的值为a的初始值。
​	代码第10行，a的二进制变为00000101，b为00000011。即b不变，取出所有不相等的位存入a。此时a的值为b的初始值。到此完成a、b两变量值的变换。算法最大的优点是省略了中间变量，但只能用于相同类型数的交换。

# 7.  列举并解释C++中的4种运算符转化以及它们的不同点

考点:位运算的灵活使用

出现频率:★★★★

4种运算符如下。
	(1) const_cast 操作符:用来帮助调用那些应该使用却没有使用const 关键字的函数。换句话说，就是供程序设计师在特殊情况下将限制为const成员函数的const定义解除，使其能更改特定属性。

​	(2) dynamic_cast 操作符:如果启动了支持运行时间类型信息（RTTI)，dynamic_cast可以有助于判断在运行时所指向对象的确切类型。它与typeid运算符有关。可以将一个基类的指针指向许多不同的子类型(派生类)，然后将被转型为基础类的对象还原成原来的类。不过，限于对象指针的类型转换，而非对象变量。

​	(3) reinterpret_cast操作符:将一个指针转换成其他类型的指针，新类型的指针与旧指针可以毫不相关。通常用于某些非标准的指针数据类型转换，例如将void \*转换为char\*。它也可以用在指针和整型数之间的类型转换上。注意:它存在潜在的危险，除非有使用它的充分理由，否则就不要使用它。例如，它能够将一个int *类型的指针转换为float *类型的指针，但是这样就会很容易造成整数数据不能被正确地读取。

​	( 4) static_cast 操作符:它能在相关的对象和指针类型之间进行类型转换。有关的类之间必须通过继承、构造函数或者转换函数发生联系。static_cast 操作符还能在数字(原始的)类型之间进行类型转换。通常情况下，static_cast操作符大多用于将数域宽度较大的类型转换为较小的类型。当转换的类型是原始数据类型时，这种操作可以有效地禁止编译器发出警告。



# 8. 用#define声明一个常数

用#define声明一个常数，用以表明1年中有多少秒?

考点:#define的使用规范

出现频率:★★★★

源代码如下:

```cpp
#define SECOND_PER_YEAR(60 * 60 *24 * 365)UL
```

面试官在这里想看到几件事情:

(1）#define语法的基本知识（例如，不能以分号结束，括号的使用，等等);

(2）懂得预处理器将为你计算常数表达式的值，因此，直接写出你是如何计算1年中有多少秒而不是计算出实际的值，是更清晰而没有代价的;

(3）意识到这个表达式将使一个16位机的整型数溢出，因此要用到长整型符号L，告诉编译器这个常数是长整型数;

(4）如果你在你的表达式中用到UL（表示无符号长整型)，那么你有了一个好的起点。记住，第一印象很重要。



# 9. 如何用C语言编写死循环

考点:死循环的编写方式

出现频率:★★★★

1. 首选方案

```cpp
while(1) {}
```

2. for

```cpp
for(;;) {}
```

​	这个实现方式会让面试官为难，因为这个语法没有确切地表达出到底是怎么回事。如果一个应试者把这个作为方案，面试官可能将用这个作为一个机会去探究应试者这样做的基本原理。如果应试者的基本答案是:“我被教着这样做，但从没有想到过为什么。”这会给面试官留下一个坏印象。

3. goto:

```cpp
Loop:
...
goto Loop;
```

​	应试者如给出上面的方案，这说明他是一个汇编语言程序员（这也许是好事）或者他是一个想进入新领域的BASIC/FORTRAN程序员。

# 10. 如何访问特定位置的内存

考点:合理编写代码，访问特定内存

出现频率:★★★★

​	嵌入式系统经常要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为0x67a9的整型变量的值为Oxaa66。编译器是一个纯粹的ANSI编译器。写代码去完成这一任务。

```cpp
int *ptr;
ptr = (int *)0x67a9;
*ptr = 0xaa66;

*(int* const)(0x67a9) = 0xaa66;
```



# 11. 对中断服务代码的评论

考点:对嵌入式系统中断服务的理解

出现频率:★★★

​	中断是嵌入式系统中重要的组成部分，这导致很多编译开发商提供一种扩展，让标准C支持中断。而事实是，产生了一个新的关键字\_interrupt。下面的代码就使用了:_interrupt关键字去定义一个中断服务子程序(ISR)，请评论一下这段代码。

```cpp
_interrupt double compute_area (double radius)
{
    double area = PI * radius * radius;
    printf("Area = %f", area);
    return area;
}
```

这个函数有以下方面的错误。
	(1）ISR不能返回一个值。如果你不懂这个，那么你是不会被雇用的。

​	(2）ISR不能传递参数。如果你没有看到这一点，那么你被雇用的机会等同于第1点。

​	(3）在许多的处理器/编译器中，浮点一般都是不可重入的。有些处理器/编译器需要让额外的寄存器入栈，有些处理器/编译器就是不允许在ISR中做浮点运算。此外，ISR应该是短且有效率的，在ISR中做浮点运算是不明智的。

​	(4)与第3点一脉相承，printf()经常有重入和性能上的问题。如果你丢掉了第3点和第4点，面试官也不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。

​	ISR 是中断服务程序的缩写，表示中断服务例程（Interrupt Service Routine）。在嵌入式系统中，当发生特定的中断事件时，处理器会暂停当前执行的任务，转而执行 ISR。ISR 负责处理中断事件，并在处理完成后将控制返回给主程序。ISR 的编写通常需要考虑中断的优先级、中断处理的时间限制等因素。



# 12. 看代码写结果—整数的自动转换
考点:对C语言中整数自动转换原则的理解

出现频率:★★★

```cpp
void foo)(void)
{
	unsigned int a =6;
    int b = -20;
    if(a+b > 6)
        puts(">6");
    else
        puts(">=6");
}
```

​	这个问题测试你是否懂得C语言中的整数自动转换原则，有些应试者极少懂得这些东西。不管如何，这无符号整型问题的答案输出是“>6”。原因是当表达式中存在有符号类型和无符号类型时，所有的操作数都自动转换为无符号类型。因此，-20变成了一个非常大的正整数，所以该表达式计算出的结果大于6。这一点对于频繁用到无符号数据类型的嵌入式系统来说是非常重要的。如果你答错了这个问题，你也就与这份工作无缘了。



# *13. 关键字static的作用是什么

考点:对C语言中关键字static 作用的理解

出现频率:★★★★★

​	这个简单的问题很少有人能完全回答。在C语言中，关键字static有以下3个明显的作用。

​	(1）在函数体内，一个被声明为静态的变量在这一函数被调用的过程中维持其值不变。

​	(2）在模块内（但在函数体外)，一个被声明为静态的变量可以被模块内所有函数访问，但不能被模块外其他函数访问。它是一个本地的全局变量。

​	(3）在模块内，一个被声明为静态的函数只可被这一模块内的其他函数调用。那就是，这个函数被限制在声明它模块的本地范围内使用。

​	大多数应试者能正确回答第Ⅰ部分，另一部分应试者能正确回答第2部分，同时很少的人能懂得第3部分。这是应试者的一个严重的不足，因为他显然不懂得本地化数据和代码范围的好处及重要性。



# 14. 关键字volatile有什么含义

考点:对C语言中关键字volatile作用的理解

出现频率:★★★

【解析】

​	一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说，就是优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。下面是volatile变量的几个例子。
​	(1）并行设备的硬件寄存器（如状态寄存器);
​	(2）一个中断服务子程序中会访问到的非自动变量(Non-automatic variables);(3）多线程应用中被几个任务共享的变量。
​	回答不出这个问题的人是不会被雇用的。这是区分C语言程序员和嵌入式系统程序员的最基本的问题。嵌入式系统程序员经常和硬件、中断、RTOS等打交道，所有这些都要求懂得volatile变量。不懂得volatile内容将会带来灾难。



# 15. 判断处理器是Big_endian还是Little_endian

编写函数，判断处理器是Big_endian还是Little_endian.

考点:对处理器字节序的理解以及union的作用

出现频率:★★★

​	这里编写一个函数，若处理器是Big _endian的，则返回0;若是Little_endian的，则返回1。

```cpp
int checkCPU()
{
	union w
    {
        int a;
        char b;
    } c;
    c.a = 1;
    return (c.b == 1); //返回为1,是Little_endian
}
```

​	嵌入式系统开发者应该对Little-endian和 Big-endian模式非常了解。采用Little-endian模式的CPU对操作数的存放方式是从低字节到高字节，而Big-endian模式对操作数的存放方式是从高字节到低字节。例如，16bit 的数0x1234在 Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为:

```cpp
0x4000: 0x34
0x4001: 0x12
```

Big-endian:

```cpp
0x4000: 0x12
0x4001: 0x34
```

​	联合体union 的存放顺序是所有成员都从低地址开始存放，利用该特性，轻松地获得了CPU 对内存采用Little-endian还是 Big-endian模式的读写。



# 16. 评价代码片断——处理器字长

考点:处理器字长的认识

出现频率:★★★

```cpp
unsigned int zero = o;
unsigned int compzero =OxFFFF;
/*1's complement of zero*/
```



​	这一问题能真正揭露出应试者是否懂得处理器字长的重要性。好的嵌入式程序员能够非常准确地明白硬件的细节和它的局限性，然而PC机程序员往往把硬件作为一个无法避免的烦恼。