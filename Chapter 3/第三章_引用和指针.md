​	引用是C++引入的新语言特性，是C++常用的一个重要内容。正确、灵活地使用引用，可以使程序简洁、高效。
​	指针是C语言中广泛使用的一种数据类型。运用指针编程是C语言最主要的风格之一。使用指针可以编写出精炼而高效的程序。学习指针是学习C语言中最重要的一环，同时，指针也是学习C语言中最为困难的一部分。
​	指针可以表示各种数据对象，例如简单变量、数组、结构体、类以及函数等。指针具有不同的类型，这些类型指向不同的数据存储体。
在各种笔试和面试中，许多指针方面的问题都是各个公司的重点考点，例如数组指针、函数指针、常量指针、指针传值、多维指针等。
​	本章通过许多实际公司面试题对指针的各个方面的重点、难点进行全面且细致的分析。通过阅读本章，希望读者能解决指针的各个难点。



# 1. 一般变量引用
仔细阅读下面的代码，并分析变量的结果和程序运行结果。

考点:一般变量引用

出现频率:★★★★

```cpp
void ex_1()
{
    int a = 10;//7
    int b = 20; //8
    int &rn = a; //9
    int equal;
    
    rn = b; //12
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    
    rn = 100; //16
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    
    equal = (&a == &rn) ? 1 : 0; //21
    std::cout << "equal = " << equal << std::endl;
}
```

输出的结果:

```cpp
a = 20
b = 20
a = 100
b = 20
equal = 1
```

​	代码第7行和第8行，整型变量a 和整型变量b分别被初始化为10和20。代码第9行，声明rn为变量a的一个引用。
​	代码第12行，将rn的值赋为b的值。此时rn其实就是a的一个别名，对rn的赋值其实就是对a的赋值。因此执行完赋值后，a的值就是b的值，即都是20。代码第16行，将rn的值赋为100，于是a的值变成了100。
​	代码第21行，将a的地址与rn的地址进行比较，如果相等，变量equal 的值为1，否则为0。将rn声明为a的引用，不需要为rn另外开辟内存单元。rn和 a占内存中的同一个存储单元，它们具有同一地址，所以equal为1。



# 2.指针变量引用

仔细阅读下面的代码，并分析变量的结果和程序运行结果。

考点:指针变量引用

出现频率:★★★★

```cpp


void ex_2()
{
    int a = 1;
    int b = 10;
    int* p = &a;
    int* &pa = p;
    
    (*pa)++;
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    std::cout << "*p = " << *p << std::endl;
    
    pa = &b;
    (*pa)++;
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    std::cout << "*p = " << *p << std::endl;
    
}
```

​	代码第5行和第6行，整型变量a和整型变量b分别被初始化为1和10。代码第7行，声明整型的指针变量p并初始指向a。
​	代码第8行，声明p的一个指针引用pa。
​	代码第10行，将pa指向的内容加1。由于pa是p 的引用，所以此时实际上是对p指向的内容加1，也就是a加1，结果为a变成了2。
​	代码第15行，将pa指向变量b的地址。由于pa是p的引用，所以此时p也指向了b的地址。
​	代码第16行，将pa指向的内容加1。由于pa是p的引用，所以此时实际上是对p指向的内容加1，也就是b加1，结果为b变成了12。

```cpp
a = 2
b = 10
*p = 2
a = 2
b = 11
*p = 11
```

# 3. 看代码找错误--变量引用
考点:一般变量引用

出现频率:★★★

```cpp



void ex_3()
{
    int a = 1, b = 2;
    // int &c; 未初始化，错误
    int &d = a;
    //&d = b; //只能在申明时候赋值，不能再将d作为其他变量的别名
    int *p;

    // *p = 5; //p没有被初始化，是个野指针，很危险，程序会崩溃
}
```

# 4. 如何交换两个字符串

考点:参数引用

出现频率:★★★

源代码如下:

```cpp
void swap(char *&x, char *&y) {
    char *temp;
    temp = x;
    x = y;
    y = temp;
}

void ex_4()
{
    char *ap = "he1lo";
    char *bp = "how are you?";
    cout << "ap: " << ap << endl;
    cout << "bp: " << bp << endl;
    swap(ap, bp);
    cout << "swap ap, bp" << endl;
    cout << "ap: " << ap << endl;
    cout << "bp: " << bp << endl;
}
```

​	这里swap函数是利用传指针引用实现字符串交换的。由于swap函数是指针引用类型,因此传入函数的就是实参，而不是形参。
​	如果不用指针引用，那么指针交换只能在swap函数中有效，因为在函数体中，函数栈会分配两个临时的指针变量分别指向两个指针参数，对实际的ap和 bp没有影响。


这两个函数在参数传递上有着根本性的区别。

1. **`void swap(char \*&x, char \*&y)`**:
   - 这个函数接受的参数是指向字符指针的引用。传递引用意味着传递的是指针变量本身，而不是指针指向的值的副本。因此，函数内对引用的修改会直接影响到原始的指针变量。这样，函数内部的指针交换操作会影响到原始的指针变量。
2. **`void swap(char \*x, char \*y)`**:
   - 这个函数接受的参数是字符指针。传递的是指针指向的值的副本，而不是指针变量本身。在函数内部，对这些指针进行交换操作并不会影响到原始的指针变量。因为指针是按值传递的，所以函数内部的交换操作只影响到了副本的指针，而不影响原始的指针。



# 5. 程序查错—参数引用
```cpp
#include <iostream>

const float pi = 3.14f;
float f;

float f1(float r) {
    f = r * r * pi;
    return f;
}

float& f2(float r) {
    f = r * r * pi;
    return f;
}

int main() {
    float f1(float=5);
    float& f2(float=5);
    float a = f1();
    float& b = f1();
    float c = f2();
    float& d = f2();
    d += 1.0f;
    std::cout << "a = " << a << std::endl;
    std::cout << "b = " << b << std::endl;
    std::cout << "c = " << c << std::endl;
    std::cout << "d = " << d << std::endl;
    std::cout << "f = " << f << std::endl;
}
```

结果:

```cpp
a = 78.5
c = 78.5
d = 79.5
f = 79.5
```

这里f1()函数返回的是全局变量f的值，f2()函数返回的是全局变量f的引用。

​	代码第18行，正确。声明函数f1()的默认参数调用，其默认参数值为5。

​	代码第19行，正确。声明函数f2()的默认参数调用，其默认参数值为5。

​	代码第20行，正确。将变量a赋为f1()的返回值。
​	代码第21行，错误。将变量b赋为f1()的返回值。因为在f1()函数里，全局变量f的值78.5赋给一个临时变量temp，这个temp变量由编译器隐式地建立，然后建立这个temp 的引用b。这里对一个临时变量temp进行引用会发生错误。
​	代码第22行，正确。f2()函数在返回值时并没有隐式地建立临时变量temp，而是直接将全局变量f返回给主函数。
​	代码第23行，正确。主函数中都不使用定义变量，而是直接使用全局变量的引用，这种方式是全部4种中最节省内存空间的。但必须注意它所引用的变量的有效期，此处全局变量f的有效期肯定长于引用d，所以是安全的。否则，会出现错误。例如，将一个局部变量的引用返回，此时全局变量f的值为78.5。
​	代码第25行，正确。将d的值加1.0，此时d是全局变量f的引用，因此f的值变成79.5。

# 6. 参数引用的常见错误

挑出下面代码中的错误。

考点:参数引用

出现频率:★★★

```cpp
class Test {
public:
    void f(const int& arg);
private:
    int value;
};


void Test::f(const int& arg) {
    // 不能修改 const 引用参数 arg 的值
    // arg = 10;
    cout << "arg = " << arg << endl;
    value = 20;
}

void ex_6()
{
    int a = 7;
    const int b = 10;
    const int &c = b; //b为常量，而c不是常量引用
    const int &d = a;
    a++;
    // const 引用可以绑定到非 const 对象
    // 但不能通过 const 引用修改非 const 对象的值
    // d++;
    Test test;
    test.f(a);
    cout << "a = " << a << endl;
}
```

​	把const放在引用之前表示声明的是一个常量引用。不能使用常量引用修改引用的变量的值。
​	代码第13行，错误。因为参数arg是一个常量引用类型的，所以 arg 的值在函数体内不能被修改。
​	代码第20行和第21行，a被声明为整型变量，b被声明为整型常量。
​	代码第22行，声明c为b的引用，错误。其原因是b为常量，而c不是常量引用
​	正确的方式应为:

```cpp
const int &c = b;
```


​	代码第23行，声明d为a的常量引用，正确。口代码第25行，变量a自增1，正确。
​	代码第26行，d自增1，错误。d是常量引用，不能对d使用赋值操作。
​	从上面的分析可以看到，对于常量类型的变量，其引用也必须是常量类型的;对于非常量类型的变量，其引用可以是非常量的，也可以是常量的。但是要注意，无论什么情况，都不能使用常量引用修改其引用的变量的值。



# *7. 指针和引用有什么区别

考点:引用和指针的区别

出现频率:★★★★★

​	(1）初始化要求不同。引用在创建的同时必须初始化，即引用到一个有效的对象;而指针在定义的时候不必初始化，可以在定义后面的任何地方重新赋值。
​	(2）可修改性不同。引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用;而指针在任何时候都可以改变为指向另一个对象。给引用赋值并不是改变它和原始对象的绑定关系。
​	(3）不存在 NULL 引用，引用不能使用指向空值的引用，它必须总是指向某个对象;而指针则可以是NULL，不需要总是指向某些对象，可以把指针指向任意的对象，所以指针更加灵活，也容易出错。
​	(4）测试需要的区别。由于引用不会指向空值，这意味着使用引用之前不需要测试它的合法性;而指针则需要经常进行测试。因此使用引用的代码效率比使用指针的要高。
​	(5）应用的区别。如果是指一旦指向一个对象后就不会改变指向，那么应该使用引用。如果有存在指向NULL(不指向任何对象）或在不同的时刻指向不同的对象这些可能性，应该使用指针。
​	实际上，在语言层面，引用的用法和对象一样;在二进制层面，引用一般都是通过指针来实现的，只不过编译器帮我们完成了转换。总体来说，引用既具有指针的效率，又具有变量使用的方便性和直观性。



# 8.为什么传引用比传指针安全

考点:引用和指针的区别

出现频率:★★★★

​	由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另个对象的引用，因此引用很安全。

​	对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。const指针仍然存在空指针，并且有可能产生野指针。



# 9. 复杂指针的声明

考点:复杂指针的声明

出现频率:★★★★★

用变量a给出下面的定义:

a.一个整型数（An integer)
b.一个指向整型数的指针（A pointer to an integer)
c.一个指向指针的指针，它指向的指针是指向一个整型数的(A pointer to a pointer to aninteger)
d.一个有10个整型数的数组(An array of 10 integers)
e.一个有10个指针的数组，该指针是指向一个整型数的（An array of 10 pointers tointegers)
f.一个指向有10个整型数数组的指针（Apointer to an array of 10 integers)
g.一个指向函数的指针，该函数有一个整型参数并返回一个整型数（A pointer to
function that takes an integer as an argument and returns an integer）
h.一个有10个指针的数组，该指针指向一个函数，该函数有一个整型参数并返回·个整型数（An array of ten pointers to functions that take an integer argument and returninteger)

```cpp
int a;
int* a;
int** a;
int a[10];
int* a[10];
int(*a)[10];
int(*a)(int)
int(*a[10])(int)
```

扩展知识:解读复杂指针声明
	使用右左法则:首先从最里面的圆括号看起，然后往右看，再往左看。每当遇到圆括号时，就应该掉转阅读方向。一旦解析完圆括号里面所有的东西，就跳出圆括号。重复这个过程，直到整个声明解析完毕。
	这里对这个法则进行一个小小的修正，应该是从未定义的标识符开始阅读，而不是从括号读起。这是因为一个声明里面未定义的标识符只会有一个。
	现在通过几个例子来讨论如何运用右左法则解读复杂指针声明。

​	

# 10. 看代码写结果——用指针赋值

考点:用指针赋值

出现频率:★★★★

```cpp


void ex_10()
{
    char a[] = "hello, world";
    char *ptr = a;

    printf("%c\n", *(ptr + 4));
    printf("%c\n", ptr[4]);
    printf("%c\n", a[4]);
    printf("%c\n", *(a + 4));

    *(ptr + 4) += 1;
    printf("%s \n", a);
}
```

输出:

```cpp
o
o
o
o
```

代码第5行，声明了一个字符数组a，并初始化为"hello, world"，包括以'\0'结束字符。
代码第6行，声明一个字符指针ptr，并初始化指向数组a首（a的第一个元素地址）。
代码第8行，这里将ptr加4，再输出地址的内容，也就指向了输出 a[4]的内容。代码第9行，ptr[4]和*(ptr+4)一样，也是a[4]的内容。
代码第10行，输出a[4]的内容。
代码第11行， (a+4)和a[4]一样，也是a[4]的内容。
代码第13行，使数组a[4]的内容加1。由于原来a[4]的内容为"hello, world"字符串的第五个字符o'，加1后就是'p'。



# 11.指针加减操作

写出下面程序的结果。

考点:指针加减操作

出现频率:★★★★

```cpp


void ex_11()
{
    int a[5] = {1, 2, 3, 4, 5};
    int *ptr = (int *)(&a + 1);

    printf("%d\n", *(a + 1));
    printf("%d\n", *(ptr - 1));
}
```

输出:

2
5



# 12. 指针比较

写出下面程序的结果。

考点:指针比较操作

出现频率:★★★★

```cpp
void ex_12()
{
    char str1[] = "abc";
    char str2[] = "abc";
    const char str3[] = "abc";
    const char str4[] = "abc";
    const char* str5 = "abc";
    const char* str6 = "abc";
    char* str7 = "abc";
    char* str8 = "abc";

    cout << (str1 == str2) << endl;
    cout << (str3 == str4) << endl;
    cout << (str5 == str6) << endl;
    cout << (str6 == str7) << endl;
    cout << (str7 == str8) << endl;
}
```

输出:

0
0
1
1
1

​	这个程序考查的是内存中各个数据的存放方式。
​	数组str1、str2、str3和 str4都是在栈中分配的，内存中的内容都为"abc"加一个'\0'，但是它们的位置是不同的。因此代码第15行和第16行的输出都是0。
​	指针str5、str6、str7和 str8也是在栈中分配的，它们都指向"abc"字符串，注意"abc"存放在数据区，所以str5、str6、str7和 str8其实指向同一块数据区的内存。因此第17、18和19行的输出是1。



# 13. 看代码找错误——内存访问违规

考点:指针操作内存违规

出现频率:★★★★

```cpp
void ex_13()
{
    char a;
    char *str1 = &a;
    char* str2 = "AAA";
    
    strcpy(str1, "hello"); //使用 strcpy 函数来将字符串复制到 str1 指向的内存中, 但是这片内存大小不够
   
    cout << str1 << endl;

    // 下面这一行会导致编译错误，因为字符串字面值 "AAA" 存储在只读数据段，不允许修改
    str2[0] = 'B'; 
    cout << str1 << endl;
}
```

字符串字面值是以双引号括起来的字符序列，例如："Hello, world!"。字符数组是一组以空字符（'\0'）结尾的字符。

下面是一些示例，展示了字符串字面值和字符数组的区别：

```cpp
// 字符串字面值
const char* str1 = "Hello, world!"; // 字符串字面值
const char* str2 = "abc123"; // 字符串字面值
const char* str3 = ""; // 空字符串字面值
const char* str4 = "Hello, \"world\"!"; // 字符串字面值中包含转义字符

// 字符数组
char arr1[] = {'H', 'e', 'l', 'l', 'o', '\0'}; // 字符数组
char arr2[] = "Hello"; // 字符数组
char arr3[10] = "abc"; // 字符数组，初始化了部分元素
char arr4[10] = {'H', 'e', 'l', 'l', 'o', '\0'}; // 字符数组，初始化了部分元素

```



# 14.指针的隐式转换

找出下面代码中的错误。

考点:指针类型的隐式转换

出现频率:★★★★

```cpp


void ex_14()
{
    int ival = 1024;
    int ival2 = 2048;
    int *pi1 = &ival;
    int *pi2 = &ival2;
    int **pi3 = nullptr;

    ival = *pi3; // 试图解引用空指针，可能导致未定义的行为
    *pi2 = *pi3; // 试图解引用空指针，可能导致未定义的行为
    ival = *pi2; // 将指针 pi2 指向的值赋给 ival
    pi2 = *pi1; // 将指针 pi1 指向的值（整型）赋给指针 pi2，类型不匹配
    pi1 = *pi3; // 将指针 pi3 指向的值（空指针）赋给指针 pi1
    ival = *pi1; // 将指针 pi1 指向的值（空指针）赋给 ival
    pi1 = &ival; // 将指针 pi1 指向 ival
    pi3 = &pi2; // 将指针 pi3 指向指针 pi2

    // 这里输出了一个数字 3，但是似乎并没有相关的语句
    printf("%d\n", 3);
}
```

​	代码第5行，正确，声明并初始化整型变量ival。

​	代码第6行，正确，声明并初始化整型变量ival2。
​	代码第7行，正确，声明整型指针变量pi1，初始化指向ival。

​	代码第8行，正确，声明整型指针变量pi2，初始化指向ival2。

​	代码第9行，正确，声明二维整型指针变量pi3，初始化为0。

​	代码第11行，编译错误，*ival是 int类型，pi3是int *类型，不能隐式转换。*

​	代码第12行，编译错误，*pi2是int类型，*pi3是int *类型，不能隐式转换。

​	代码第13行，编译错误，ival是 int类型，pi2是int *类型，不能隐式转换。

​	代码第14行，编译错误，pi2是 int *类型，*pil是 int类型，不能隐式转换。

​	代码第15行，运行时错误，pi3是 NULL指针，试图得到*pi3的值会发生运行错误。

​	代码第16行，正确，将ival的值赋为pil。

​	代码第17行，编译错误，pil是int *类型，ival是 int类型，不能隐式转换。

​	代码第18行，正确，将pi3的值赋为&pi2，都是int **类型。

​	本题中错误的类型有两种，一种是编译错误，另一种是运行时错误。导致编译错误的是类型之间不能隐式转换，如int转换成int\*、int\*转换成int等。导致运行时错误是因为在 Windows平台，进程的内存空间有一块是专门用于NULL 指针分配的分区，这个分区的地址空间是禁止进入的，因此就会发生内存访问违规现象，同时该进程将终止运行。



# *15.指针常量与常量指针的区别

​	这里有个小规则，像这样连着的两个词，前面的一个通常是修饰部分，中心词是后面一个词。

​	常量指针，表述为“是常量的指针”，它首先应该是一个指针。

​	指针常量，表述为“是指针的常量”，它首先应该是一个常量。接下来进行详细分析。

​	常量指针，它是一个指向常量的指针。设置常量指针指向一个常量，为的就是防止写程序过程中对指针误操作出现了修改常量这样的错误，编译系统就会提示我们出错信息。因此，常量指针就是指向常量的指针，指针所指向的地址的内容是不可修改的。

​	指针常量，它首先是一个常量，然后才是一个指针。指针常量就是不能修改这个指针所指向的地址，一开始初始化指向哪儿，它就只能指向哪儿了，不能指向其他的地方了，就像一个数组的数组名一样，是一个固定的指针，不能对它移动操作。如果使用p++，系统就会提示出错。但是注意，这个指向的地方里的内容是可以替换的，这和上面说的常量指针是完全不同的概念。总之，指针常量就是指针的常量，它是不可改变地址的指针，但是可以对它所指向的内容进行修改。

​	常量指针就是指向常量的指针，它所指向的地址的内容是不可修改的。

​	指针常量就是指针的常量，它是不可改变地址的指针，但是可以对它所指向的内容进行修改。



# *16. 指针的区别

```cpp
char * const p1;
char const * p2;
const char *p3;
const char * const p4;
```

​	如果const位于\*号的左侧，则const就是用来修饰指针所指向的变量，即指针指向为常量;如果const位于*号的右侧，const就是修饰指针本身，即指针本身是常量。因此，p1指针本身是常量，但它指向的内容可以被修改。p2和p3的情况相同，都是指针所指向的内容为常量。p4则表示指针本身是常量，并且它指向的内容也不可被修改。

​	p1是指针常量，它本身不能被修改，指向的内容可以被修改。

​	p2和p3是常量指针，它本身可以被修改，指向的内容不可以被修改。

​	p4本身是常量，并且它指向的内容也不可被修改。



# 17. 找错--常量指针和指针常量的作用
```cpp
#include <stdio.h>

int main() {
    const char *node1 = "abc"; // 指向常量字符串的指针
    char *const node2 = "abc"; // 指向常量字符串的常指针

    // 下面的操作都是非法的，因为它们尝试修改常量字符串
    // node1[2] = 'k'; // 非法，尝试修改常量字符串的字符
    // *node1[2] = 'k'; // 非法，尝试修改常量字符串的字符
    // *node1 = "xyz"; // 非法，尝试修改指针所指向的地址
    node1 = "xyz"; 
    // node2[2] = 'k'; // 非法，尝试修改常量字符串的字符
    // *node2[2] = 'k'; // 非法，尝试修改常量字符串的字符
    // *node2 = "xyz"; // 非法，尝试修改指针所指向的地址
    // node2 = "xyz"; // 非法，尝试修改指针所指向的地址

    return 0;
}
```



# 18.this指针的正确叙述

下列关于this指针的叙述中，正确的是（)。
A．任何与类相关的函数都有this指针
B．类的成员函数都有this指针
C．类的友元函数都有this指针
D．类的非静态成员函数才有this指针

A错误。类的非静态成员函数是属于类的对象，含有this 指针。而类的static函数属于类本身，不含this 指针。

B错误。类的非静态成员函数是属于类的对象，含有this指针。而类的static函数属于类本身，不含this 指针。

C错误。友元函数是非成员函数，所以它无法通过 this指针获得一份拷贝。

D正确。



# 19. 看代码写结果-this指针
```cpp
class MyClass {
public:
    int data;
    MyClass(int data) {
        this->data = data;
    }
    void print() {
        cout << data << endl;
        cout << "hello" << endl;
    }
};

void ex_19()
{
    MyClass *pMyClass;
    pMyClass = new MyClass(1);
    pMyClass->print();

    // 创建了一个 MyClass 类型的指针数组
    MyClass *pMyClassArray = new MyClass[3]{2, 3, 4};

    // 通过指针数组访问不同的 MyClass 对象并调用 print 方法
    pMyClassArray[0].print();
    pMyClassArray[1].print();
    pMyClassArray[2].print();

    // 尝试访问超出数组范围的元素，这是未定义行为
    // pMyClassArray[10000000].print();

    // 释放动态分配的内存
    delete pMyClass;
    delete[] pMyClassArray;
}
```

​	这里需要明白类函数是如何被编译以及如何被执行的。
​	对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。当程序被编译之后，此成员函数地址即已确定。我们常说，调用类成员函数时，会将当前对象的 this 指针传给成员函数。没错，一个类的成员函数体只有一份，而成员函数之所以能把属于此类的各个对象的数据区别开，就在于每次执行类成员函数时，都会把当前对象的 this指针（对象首地址）传入成员函数，函数体内所有对类数据成员的访问，都会被转化为this->数据成员的方式。
​	如果print函数里没有访问对象的任何数据成员，那么此时传进来的对象this指针实际上是没有任何用处的。这样的函数，其特征与全局函数并没有太大区别。但如果取消第14行的注释，由于 print函数要访问类的数据成员data，而类的数据成员是伴随着对象声明而产生的。但是，我们只new了一个MyClass，显然，下标"1"和下标"10000000"的 MyClass对象根本不存在，那么对它们的数据成员访问也显然是非法的。



# *20.指针数组与数组指针的区别

​	指针数组指一个数组里存放的都是同一个类型的指针，例如
```cpp
int* a[ 10];
```

​	数组a里面存放了10个int\*型变量，由于它是一个数组，已经在栈区分配了10个(int*）的空间，也就是32位机上是40个byte，每个空间都可以存放一个int型变量的地址。这个时候，你可以为这个数组的每一个元素初始化。
​	数组指针指一个指向一维或者多维数组的指针，例如:

```cpp
int * b=new int[ 10];
```

​	指针b指向含有10个整型数据的一维数组。注意，这个时候释放空间一定要delete ],否则会造成内存泄露。
​	参考下面的源代码:

```cpp
void ex_20()
{
    int x1[4] = {1, 2, 3, 4};
    int x2[2] = {5, 6};
    int x3[3] = {7, 8, 9};
    int* a[2];
    int* b = x1;
    int i = 0;

    a[0] = x2;
    a[1] = x3;

    cout << "输出a[0]: ";
    for(i = 0; i < sizeof(x2) / sizeof(int); i++) {
        cout << a[0][i] << " ";
    }
    cout << endl;

    cout << "输出a[1]: ";
    for(i = 0; i < sizeof(x3) / sizeof(int); i++) {
        cout << a[1][i] << " ";
    }
    cout << endl;

    cout << "输出b: ";
    for(i = 0; i < sizeof(x1) / sizeof(int); i++) {
        cout << b[i] << " ";
    }
    cout << endl;
}
```

输出： //可以用首地址加下标进行访问

输出a[0]: 5 6 
输出a[1]: 7 8 9
输出b: 1 2 3 4

# 21 找错——指针数组和数组指针的使用

```cpp
void ex_21()
{
    char *str[] = { "Welcome", "to", "Fortemedia", "Nanjing" };//5
    char **p = str + 1;
    str[0] = (*p++) + 2;
    str[1] = *(p + 1);
    str[2] = p[1] + 3;
    str[3] = p[0] + (str[2] - str[1]);

    printf("%sIn", str[0]);
    printf("%s\n", str[1]);
    printf("%sin", str[2]);
    printf("%sin", str[3]);
}
```

​	本题的每次执行都较强地依赖于上一个语句执行的情况，好几次一个语句，同时修改str和p的值。
代码第5行结束时，str是下面数组的第一个值。
​	(1）第1个字符串的首地址的存放地址，标记为A，其内容为"Welcome"。

​	(2）第2个字符串的首地址的存放地址，标记为B，其内容为"to"。

​	(3）第3个字符串的首地址的存放地址，标记为C，其内容为"Fortemedia"。

​	(4）第4个字符串的首地址的存放地址，标记为D，其内容为"Nanjing"。代码第6行结束时，p指向B。



​	代码第7行结束时，p指向C。此时str[0]指向第4个字符串"Nanjing"后面的元素，因此其内容为空。
​	代码第8行结束时，p没有移动，str[1]指向p的后一个元素地址，即D。
​	代码第9行，此时p[1]指向D。p[1] +3即指向字符串的元素的第4个元素，即j字符。此行执行之后，str[2]等于j'的地址。
​	代码第10行，由第8行和第9行可知str[2] - str[1]等于3，而p[0]指向j'的地址。因此str[4]指向"Nanjing"字符串中的最后一个字符'g'的地址。



# *22.函数指针与指针函数的区别

​	指针函数是指带指针的函数，即本质是一个函数，并且返回类型是某一类型的指针。其定义如下:

​	返回类型标识符*返回名称（形式参数表){ 函数体}



​	事实上，每一个函数，即使它不带有返回某种类型的指针，它本身都有一个入口地址，该地址相当于一个指针。比如函数返回一个整型值，实际上也相当于返回一个指针变量的值，不过这时的变量是函数本身而已，而整个函数相当于一个“变量”。
​	函数指针是指向函数的指针变量，因而它本身首先应是指针变量，只不过该指针变量指向函数。有了指向函数的指针变量后，可用该指针变量调用函数，就如同用指针变量可引用其他类型的变量一样。

```cpp
int max(int x, int y) {
    return (x > y ? x : y);
}

float *find(float *p, int x) {
    return p + x;
}

void ex_22()
{
    float score[] = { 10, 20, 30, 40 };
    int (*p)(int, int);
    float *q = find(score + 1, 1);
    int a;
    p = max;
    a = (*p)(1, 2);
    cout << "a = " << a << endl;
    cout << "*q=" << *q << endl;
}
```

​	这里，函数find()被定义为指针函数，指针p被定义为函数指针类型。main函数中调用find()函数时，将数组中第2个元素的地址和偏移量1传入，返回的应该是数组中第3个元素的地址。对于指针p，在第21行被赋为max()函数的地址，因此在第22行使用指针p就能完成调用max()函数的目的。输出如下:

```cpp
a = 2
*q=30
```

指针函数是返回指针类型的函数。

函数指针是指向函数地址的指针。



# 23. 数组指针与函数指针的定义

考点:数组指针与函数指针的定义

出现频率:★★★

定义下面的几种类型变量:

a．含有10个元素的指针数组

b．数组指针

c．函数指针

d．指向函数的指针数组

```cpp
int* a[10];
int *a = new int[10];
int (*fn) (int,int);
int (*a[10])(int,int);  
```



# 24. 各种指针的定义

考点:各种指针的定义

出现频率:★★★

写出函数指针、函数返回指针、const指针、指向const 的指针、指向const的const 指针。

【答案】
```cpp
void(*fn)(int,int) //fn是指向void
int *fn() //返回int指针类型的函数
const int* p //p是一个指向const的指针，指向一个常量
int * const q //q是一个const指针
const int* const ptr //指向const的const指针
```



# 25. 代码改错--函数指针的使用
考点:函数指针的使用

出现频率:★★★★

下面的程序有什么问题?它打印出3个数的最大者。

```cpp
int max1(int x, int y) {
    return x > y ? x : y;
}
void ex_25()
{
    int (*p)(int, int); //改正
    int a, b, c;
    int result;

    p = max1;

    cout << "Please input three integers: ";
    cin >> a >> b >> c;

    result = (*p)((*p)(a, b), c);

    cout << "result = " << result << endl;
}
```



# 26. 看代码写结果-函数指针的使用
```cpp
int add1(int a1, int b1) {
    return a1 + b1;
}

int add2(int a2, int b2) {
    return a2 + b2;
}
void ex_26()
{
    int numa1 = 1, numb1 = 2;
    int numa2 = 2, numb2 = 3;
    int (*op[2])(int a, int b);

    op[0] = add1;
    op[1] = add2;

    printf("%d %d\n", op[0](numa1, numb1), op[1](numa2, numb2));

    getchar();
}
```

​	在代码第8行，定义了一个函数指针数组op，它含有两个指针元素。在第9行和第10行把这两个元素分别指向了add1和 add2两个函数地址。最后在第11行打印出使用函数指针调用add1和 add2这两个函数返回的结果。

【答案】
	3

​	5

# 27.typedef 用于函数指针定义

考点:函数指针定义中typedef的作用

出现频率:★★★

下面的定义有什么作用?

```cpp
typedef int (*pfun) (int x,int y) ;
```

​	这里的 pfun是一个使用typedef自定义的数据类型。它表示一个函数指针，其参数有两个，都是int类型，返回值也是int类型。可以按如下步骤使用:

```cpp
typedef int (*pfun) (int x,int y);
int fun(int x, int y);
pfun p = fun;
int ret = p(2,3);
```

​	第1行定义了pfun类型，表示一个函数指针类型。

​	第2行定义了一个函数。

​	第3行定义了一个pfun类型的函数指针p，并赋给它fun的地址。

​	第4行调用p(2,3)，实现fun(2,3)的调用功能。

​	定义了一个函数指针类型，表示指向返回值为int，且同时带2个int参数的函数指针类型了。可以用这种类型定义函数指针来调用相同类型的函数。



# 28. 什么是“野指针”?

考点:“野指针”是什么以及它的作用

出现频率:★★★★

​	“野指针”不是NULL指针，而是指向“垃圾”内存的指针。人们一般不会错用NULL指针，因为用if语句很容易判断。但是“野指针”是很危险的，if语句对它不起作用。“野指针”的成因主要有两种:

​	指针变量没有被初始化。任何指针变量刚被创建时不会自动成为NULL指针，它的默认值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。
​	指针p被free或者delete之后，没有置为NULL，让人误以为p是个合法的指针。

​	“野指针”不是NULL指针，而是指向“垃圾”内存的指针。其成因主要为:指针变量没有被初始化，或指针p被free或者delete之后，没有置为NULL。



# 29. “野指针”排错

```cpp
short *bufptr;
short bufarray [20];
short var=Ox20;
*bufptr = var;
bufarry [0] = var;
```

​	代码第1行，正确。声明了一个short *类型的指针，并且没有对它初始化。

​	代码第2行，正确。声明了一个20个元素的数组，每个元素都是short类型。

​	代码第3行，正确。声明了short类型的变量var，并且把它初始化为0x20。

​	代码第4行，错误。将bufptr 指针指向的内容赋为var变量的值。因为 bufptr没有被初始化，是

个“野指针”，因此对它所指向的内容操作是十分危险的，会导致程序崩溃。为了杜绝这种错误，可以

将bufptr正确地进行初始化。代码第1行改为:

```cpp
short *bufptr = ( short *)malloc (sizeof (short)) ;
```

​	代码第5行，正确。把 bufarray 的第一个元素赋值为变量 var的值。



# 30. 有了malloc/free，为什么还要new/delete

​	malloc 与free是C++/C的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
​	对于非内部数据类型的对象而言，光用malloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于 malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。
​	因此，C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。注意: new/delete不是库函数。请看下面的例子。

虽然它们的目的相同，但在使用上有一些区别：

1. **类型安全性**：`new` 和 `delete` 是C++运算符，能够正确地处理对象的构造和析构，因此更适合用于动态分配和释放类对象。而 `malloc` 和 `free` 只是C语言的函数，无法处理类对象的构造和析构，因此在使用时需要格外小心，以避免内存泄漏和资源管理问题。
2. **对齐要求**：`new` 运算符会根据类型的对齐要求来分配内存，因此分配的内存地址通常是按照类型的对齐方式进行对齐的。而 `malloc` 函数则没有这样的保证，分配的内存地址可能不是按照类型的对齐方式对齐的。
3. **异常处理**：`new` 运算符在分配内存失败时会抛出异常 `std::bad_alloc`，而 `malloc` 函数在分配内存失败时返回空指针，需要手动检查是否分配成功。
4. **数组分配**：`new` 运算符可以直接用于分配数组，而 `malloc` 函数则需要手动计算数组的大小并分配相应大小的内存。

综上所述，虽然 `new` 和 `delete` 和 `malloc` 和 `free` 都可以用于动态分配和释放内存，但在C++中更推荐使用 `new` 和 `delete`，因为它们更安全、更方便、更适合用于类对象的动态分配和释放。

```cpp
class obj {
public:
    obj() {
        cout << "Initialization" << endl;
    }
    ~obj() {
        cout << "Destroy " << endl;
    }
};

void UseMallocFree() {
    cout << "in UseMallocFree()..." << endl;
    obj *a = (obj*)malloc(sizeof(obj));
    free(a);
}

void UseNewDelete() {
    cout << "in UseNewDelete()..." << endl;
    obj *a = new obj;
    delete a;
}

void ex_30()
{
    UseMallocFree();
    UseNewDelete();
}

```

​	在这个示例中，类Obj只有构造函数和析构函数的定义，这两个成员函数分别打印一句话。函数UseMallocFree()中调用malloc/free申请和释放堆内存;函数UseNewDelete ())中调用new/delete申请和释放堆内存。可以看到函数UseMallocFree()执行时，类Obj的构造函数和析构函数都不会被调用;而函数UseNewDelete ()执行时，类Obj的构造函数和析构函数都会被调用。执行结果如下:

```cpp
in UseMallocFree()...
in UseNewDelete()...
Initialization
Destroy
```

​	对于非内部数据类型的对象而言，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能把执行构造函数和析构函数的任务强加malloc/free，因此只有使用new/delete运算符。

# 31. 程序改错--指针的初始化
考点:“野指针”必须初始化为NULL

出现频率:★★★



# 32. 各种内存分配和释放的函数的联系和区别
考点:C语言的各种标准内存分配函数的使用

出现频率:★★★

C语言的标准内存分配函数: malloc、calloc、realloc、free等。malloc 与 calloc的区别为1块与n块的区别。

​	malloc 的调用形式为(类型\*)malloc(size):在内存的动态存储区中分配一块长度为“size”字节的连续区域，返回该区域的首地址，此时内存中的值没有初始化，是个随机数。
​	calloc的调用形式为(类型\*)calloc(n，size):在内存的动态存储区中分配n块长度为“size”字节的连续区域，返回首地址，此时内存中的值都被初始化为0。
​	realloc的调用形式为(类型\*)realloc(*ptr，size):将ptr内存大小增大到size，新增加的内存块没有初始化。
​	free的调用形式为free(void\*ptr):释放 ptr所指向的一块内存空间。

​	C++中，new/delete函数可以调用类的构造函数和析构函数。



# 33. 程序找错--动态内存的传递
考点:动态内存的传递

出现频率:★★★★

```cpp
class Base {
private:
    char *name;

public:
    Base(char *className) {
        name = new char[strlen(className) + 1]; //记得加1,末尾还有'\0'
        strcpy(name, className);
    }

    ~Base() {
        delete[] name;
    }

    char *copyName() {
        char *newname = new char[strlen(name) + 1];//记得加1,末尾还有'\0'
        strcpy(newname, name);
        return newname;
    }

    char *getName() {
        return name;
    }
};

class Subclass : public Base {
public:
    Subclass(char *className) : Base(className) {
    }
};

void ex_33()
{
    Base *pBase = new Subclass("test");
    printf("name: %s\n", pBase->getName());
    printf("new name: %s\n", pBase->copyName());
    delete pBase;
}
```



# 34. 动态内存的传递

分析下面的代码。

考点:动态内存的传递

出现频率:★★★★

```cpp
#include <iostream>
#include <cstring>
using namespace std;

void GetMemory(char* &p, int num) {
    p = (char*)malloc(sizeof(char) * num); //6
}

int main(void) {
    char* str = NULL;
    GetMemory(str, 10);
    strcpy(str, "hello"); //14
    cout << str << endl;
    free(str); // Don't forget to free the allocated memory
    return 0;
}
```

​	这里的GetMemory函数有问题。GetMemory函数体内的p实际上是main函数中的str变量在GetMemory函数栈中的一个备份，因为编译器总是为函数的每个参数制作临时的变量。因此，虽然在代码第6行中p申请了堆内存，但是返回到main 函数时，str还是NULL，并不指向那块堆内存。在代码第14行，调用strcpy时会导致程序崩溃。
​	实际上，GetMemory并不能做任何有用的事情。这里还要注意，由于从GetMemory 函数返回时不能获得堆中内存的地址，那块堆内存就不能被继续引用，也就得不到释放，因此调用一次GetMemory函数就会产生num字节的内存泄漏。
​	可以采用3种方法来解决上面的动态内存不能传递的问题:

​	1. 在C语言中，可以通过采用指向指针的指针解决这个问题，可以把 str的地址传给函数GetMemory。

	2. 在C++中，多了一种选择，就是传递str指针的引用。
	2.  使用函数返回值来传递动态内存

```cpp
void GetMemory (char *p, int num){
	p =(char * )malloc (sizeof (char) *num) ;
};
void GetMemory2(char **p, int num){
	*p =(char *)malloc(sizeof (char)*num) ;
};
void GetMemory3 ( char* &p，int num){
	p =(char * )malloc (sizeof (char) *num) ;
};
char *GetMemory4 (int num)
{  
	char *p = (char * )malloc(sizeof(char) *num);
	return p;
}
```

​	在上面的代码中，GetMemory2()函数采用二维指针作为参数传递;GetMemory3()函数采用指针的引用作为参数传递;GetMemory4()函数采用返回堆内存指针的方式。可以看到这3个函数都能起到相同的作用。

​	另外注意，这里在主函数推出之前把指针str2、str3和 str4 指向的堆内存释放并把指针赋为NULL。每当决定不再使用堆内存时，应该把堆内存释放，并把指针赋为NULL，这样能避免内存泄漏以及产生野指针，是良好的编程习惯。



# *35.比较分析两个代码段的输出─-动态内存的传递

考点:动态内存的传递

出现频率:★★★★★

```cpp
#include <iostream>
using namespace std;

char* GetMemory() {
    char* p = new char[12]; // 分配动态内存
    strcpy(p, "hello world"); //加上复制
    return p;
}

void Test() {
    char* str = GetMemory();
    cout << str << endl; // 输出动态分配的字符串
    delete[] str; // 释放动态分配的内存
}
```

```cpp
void GetMemory(char*& p) { //加上了&
    p = (char*)malloc(100);
}

void Test() {
    char* str = NULL;
    GetMemory(str);
    strcpy(str, "hello world");
    cout << str << endl;
    free(str); // 释放内存
}
```

​	程序1的GetMemory()返回的是指向栈内存的指针，该指针的地址不是NULL，但是当栈退出后，内容不定，有可能会输出乱码。
​	程序2的 GetMemory()没有返回值，这个函数不能传递动态内存。在 Test函数中，str变量的值通过参数传值的方式赋给GetMemory()的局部变量p。但是 Test()中的 str一直为NULL，所以第10行中的调用会使程序崩溃。此外，由于堆内存在GetMemory()执行之后没有指针引用它，因此会产生内存泄露。

# 36.程序查错——“野指针”用于变量值的互换

考点:“野指针”不能用于变量值的互换

出现频率:★★★

```cpp
swap(int* p1, int* p2)
{
	int *p;
    *p= *p1;
    *p1 = *p2;
    *p2= *p;
}
```

​	在代码第3行，声明了一个指针p，由于没有对p初始化，p是个野指针，它可能指向系统区。因此在代码第4行，对p指向的内存区赋值非常危险，会导致程序运行时崩溃。程序应改为:

```cpp
swap(int* p1, int* p2)
{
	int p; //32位
    p = *p1;
    *p1 = *p2;
    *p2 = p;
}
```

​	swap函数内的指针变量p没有初始化是野指针，野指针可能乱指一气，导致程序运行时崩溃。



# *37. 内存的分配方式有几种

考点:静态存储区、栈、堆的内存分配

出现频率:★★★★★

(1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在，例如全局变量。

(2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。处理器的指令集中有关于栈内存的分配运算，因此效率很高，但是分配的内存容量有限。

(3）从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。



# 38. 什么是句柄

​	句柄在 Windows 编程中是一个很重要的概念，在许多地方都扮演着重要的角色。在Windows环境中，句柄是用来标识项目的，这些项目包括:

​	模块（module）。任务(task）。实例( instance）。文件（file）。

​	内存块（block of memory) 。菜单(menu）。

​	控制(control)。字体( font）。

​	资源（resource），包括图标（icon）、光标（cursor)、字符串(string）等。

​	GDI对象（GDI object），包括位图(bitmap)，画刷（brush)、元文件(metafile),调色板(palette)、

画笔(pen)、区域(region)，以及设备描述表(device context)。



​	Windows是一个以虚拟内存为基础的操作系统。在这种系统环境下，Windows内存管理器经常在内存中来回移动对象，以此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。由于地址总是如此变化，所以 Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这地址（存储单元的位置）本身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load）时由系统分配给的，当系统卸载时(Unload）又释放给系统。
​	因此，Windows程序中并不是用物理地址来标识一个内存块、文件、任务或动态装入模块的，相反，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。
​	在 Windows编程中会用到大量的句柄，比如 HINSTANCE(实例句柄)、HBITMAP(位图句柄)、HDC（设备描述表句柄)、HICON(图标句柄）等。这当中还有一个通用的句柄,就是HANDLE，比如下面的语句:

```
HINSTANCE hInstance;
HANDLE hInstance;
```

​	句柄地址（稳定）→记载着对象在内存中的地址→对象在内存中的地址（不稳定）→实际对象。但是，必须注意的是，程序每次重新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确是不一样的。

# 39. 指针与句柄有什么区别

​	指针对应着一个数据在内存中的地址，得到了指针就可以自由地修改该数据。Windows并不希望一般程序修改其内部数据结构，因为这样太不安全。所以 Windows给每个使用GlobalAlloc等函数声明的内存区域指定一个句柄，句柄是一种指向指针的指针。

​	句柄和指针都是地址，不同之处在于:
​	(1）句柄所指的可以是一个很复杂的结构，并且很有可能是与系统有关的。比如说线程的句柄，它指向的就是一个类或者结构，它和系统有很密切的关系。当一个线程由于不可预料的原因而终止时，系统就可以返回它所占用的资料，如 CPU、内存等。反过来想可以知道，这个句柄中的某一些项是与系统进行交互的。由于Windows 系统是一个多任务的系统，它随时都可能要分配内存、回收内存、重组内存。
​	(2）指针也可以指向一个复杂的结构，但是通常是由用户定义的，所以必需的工作都要用户完成，特别是在删除的时候。