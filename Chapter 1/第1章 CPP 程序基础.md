 # 1.看代码写输出 -- 一般赋值语句



```cpp
void ex_1()
{
    int x = 3, y, z;

    // 复合赋值运算 x = 12
    x *= (y = z = 4);
    printf("x = %d\n", x);

    z = 2;

    // 赋值运算 x = 2
    x = (y = z);
    printf("x = %d \n", x);

    // 相等比较运算 x = 1
    x = (y == z);
    printf("x = %d \n", x);

    // 位运算 AND x = 2
    x = (y & z);
    printf("x = %d\n", x);

    // 逻辑运算 AND x = 1
    x = (y && z);
    printf("x = %d\n", x);

    y = 4;

    // 位运算 OR x = 6
    x = (y | z);
    printf("x = %d\n", x);

    // 逻辑运算 OR (注意：应该使用 || 而不是 il) x = 1
    x = (y || z); 
    printf("x = %d\n", x);

    // 条件运算符 x = 5
    x = (y == z) ? 4 : 5;
    printf("x = %d\n", x);

    // 嵌套条件运算符 x = 3
    x = (y == z) ? 1 : (y < z) ? 2 : 3;
    printf("x = %d\n", x);
}
```



# 2. 看代码写输出-- C++域操作符

```cpp
int value = 0;
void printValue()
{
    printf("value = %d\n", value);
}
void ex_2()
{
    int value = 0;
    value = 1;
    printf ( "value = %d\n", value);
    ::value = 2; //修改全局变量
    printValue() ; //打印全局变量的值
}
```

输出:

```cpp
value = 1
value = 0
```



# 3. 看代码写输出——i++和++i的区别

```cpp
void ex_3()
{
    int i = 8;
    printf("%d\n", ++i); //9
    printf("%d\n", --i); //8
    printf("%d\n", i++); //8
    printf("%d\n", i--); //9
    printf("%d\n", -i++); //-8
    printf("%d\n", -i--); //-9
    printf("---\n");
}
```



# 4.  i++与++i哪个效率更高

内建数据类型的情况，效率没有区别。

自定义数据类型的情况，+ti效率较高。





# 5. 选择编程风格良好的条件比较语句

A． 假设布尔变量名字为flag，它与零值比较的标准if语句如下。

第一种：`if (flag == TRUE)` 和 `if (flag == FALSE)`

第二种： `if (flag)` 和 `if (!flag)`

A的第二种风格较良好。根据布尔类型的语义，零值为“假”（记为FALSE),任何非零值都是“真”（记为TRUE）。TRUE的值究竟是什么并没有统一的标准。例如 Visual C++将 TRUE定义为1，而 Visual Basic则将TRUE定义为-1。因此不可将布尔变量直接与TRUE、FALSE进行比较。



B. 整型变量与零值比较：

- 第一种：`if (value == 0)` 和 `if (value != 0)`
- 第二种：`if (value)` 和 `if (!value)`，

B的第一种风格较良好，第二种风格会让人误解value是布尔变量，应该将整型变量用“==”或“!=”直接与0比较。



C. 浮点变量与零值比较：

- 第一种：`if (x == 0.0)` 和 `if (x != 0.0)`
- 第二种：`if ((x >= -EPSILON) && (x <= EPSILON))`

EPSILON 是允许误差的精度。

C的第二种风格较良好。注意:无论是float还是double类型的变量，都有精度限制。所以一定要避免将浮点变量用“==”或“!=”与数字比较，应该设法转化成“>=”或“<=”形式。



D. 指针变量与零值比较：

- 第一种：`if (p == NULL)` 和 `if (p != NULL)`
- 第二种：`if (p)` 和 `if (!p)`，

D的第一种风格较良好，指针变量的零值是“空”(记为 NULL)。尽管NULL的值与О相同，但是两者意义不同。用p 与NULL显式比较，强调p是指针变量。如用p与0比较，容易让人误解p是整型变量。



# 6.看代码写结果——有符号变量与无符号变量的值的转换

```cpp
#include <stdio.h>

char getChar(int x, int y) {
    char c;
    unsigned int a = (unsigned int)x; // 转换为无符号整数
    (a + y > 10) ? (c = 1) : (c = 2);
    return c;
}

int main(void) {
    char c1 = getChar(7, 4);
    char c2 = getChar(7, 3);
    char c3 = getChar(7, -7);
    char c4 = getChar(7, -8);

    printf("c1 = %d \n", c1);
    printf("c2 = %d\n", c2);
    printf("c3 = %d\n", c3);
    printf("c4 = %d\n", c4);

    return 0;
}

```

首先说明 getChar() 函数的作用:它有两个输入参数，分别是整型的x和y。在函数体内，把参数x的值转换为无符号整型后再与y相加，其结果与10进行比较，如果大于10，则函数返回1，否则返回2。在这里，我们要注意:当表达式中存在有符号类型和无符号类型时，所有的操作数都自动转换成无符号类型。因此，这里由于a是无符号数，在代码第8行中，y值会首先自动转换成无符号的整数,然后与a相加,最后再与10进行比较。以下是在main函数中各调用 getChar() 函数的分析。



代码第14行，传入的参数分别为7和4，两个数相加后为11，因此c1返回1。

代码第15行，传入的参数分别为7和3，两个数相加后为10，因此c2返回2。

代码第16行，传入的参数分别为7和-7，-7首先被转换成一个很大的数，然后与7相加后正好溢出，其值为0，因此c3返回2。
代码第17行，传入的参数分别为7和-8，-8首先被转换成一个很大的数，然后与7相加。两个数相加后为很大的整数（差1就正好溢出了)，因此c4返回1。



# 7. 不适用任何中间变量如何将a, b 的值进行转换?

```cpp
#include <stdio.h>

void swap1(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

void swap2(int& a, int& b) {
    a = a + b;
    b = a - b;
    a = a - b;
}

void swap3(int& a, int& b) {
    a ^= b;
    b ^= a;
    a ^= b;
}

int main(void) {
    int a1 = 1, b1 = 2;
    int a2 = 3, b2 = 4;
    int a3 = 5, b3 = 6;
    int a = 2147483647, b = 1;

    swap1(a1, b1);
    swap2(a2, b2);
    swap3(a3, b3);

    printf("after swap...\n");
    printf("a1 = %d, b1 = %d\n", a1, b1);
    printf("a2 = %d, b2 = %d\n", a2, b2);
    printf("a3 = %d, b3 = %d\n", a3, b3);

    swap2(a, b);
    printf("a = %d, b = %d\n", a, b);

    return 0;
}

```

swap1()采用的是我们在许多教科书里看到的方式，用一个局部变量 temp保存其中一个值来达到交换目的。当然，这种方式不是本题要求的答案。

swap2()采用的是一种简单的加减算法来达到交换a、b的目的。这种方式的缺点是做a+b和a-b运算时可能会导致数据溢出。

swap3()采用了按位异或的方式交换a、b。按位异或运算符“”的功能是将参与运算的两数各对应的二进制位相异或，如果对应的二进制位相同，则结果为0，否则结果为1。这样运算3次即可交换a、b的值。

1. 第一次异或：a = A ^ B
2. 第二次异或：b = a ^ B = (A ^ B) ^ B = A ^ (B ^ B) = A ^ 0 = A
3. 第三次异或：a = a ^ B = (A ^ B) ^ A = B ^ (A ^ A) = B ^ 0 = B



# 8.C++与C有什么不同

​	C是一个结构化语言，它的重点在于算法和数据结构。对语言本身而言,C是C++的子集。C程序的设计首要考虑的是如何通过一个过程，对输入进行运算处理，得到输出。对于C++，首要考虑的是如何构造一个对象模型，让这个模型能够配合对应的问题，这样就可以通过获取对象的状态信息得到输出或实现过程控制。

​	因此，C与C++的最大区别在于，它们用于解决问题的思想方法不一样。
​	C实现了C++中过程化控制及其他相关功能。而在C++中的C，相对于原来的C还有所加强，引入了重载、内联函数、异常处理等。C++更是拓展了面向对象设计的内容，如类、继承、虚函数、模板和包容器类等。
​	在C++中，不仅需要考虑数据封装，还需要考虑对象粒度的选择、对象接口的设计和继承、组合与继承的使用等问题。
​	相对于C，C++包含了更丰富的设计概念。



# 9.如何理解C++是面向对象化的，而C是面向过程化的

​	C是面向过程化的，但是C++不是完全面向对象化的。在C++中也完全可以写出与C一样过程化的程序，所以只能说C++拥有面向对象的特性。Java是真正面向对象化的。



# 10.标准头文件的结构

为什么标准头文件都有类似以下的结构?

* 考点:标准头文件中一些通用结构的理解

```cpp
#ifndef __INCvxWorksh
#define _INCvxWorksh
#ifdef __cplusplus
extern "C" {
#endif
/*...*/
#ifdef __cplusplus
}
#endif
#endif /* __INCvxWorksh */
```

显而易见，代码第1、2、10行的作用是防止该头文件被重复引用。

代码第3行的作用是表示当前使用的是C++编译器。如果要表示当前使用的是C编译器，可以这样指定:

```cpp
#ifdef _STDC_
```

​	extern "C"包含双重含义。
​	首先，被它修饰的目标是“extern”的。也就是告诉编译器，其声明的函数和变量可以在本模块或其他模块中使用。通常，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量以关键字extern声明。例如，当模块B欲引用该模块A中定义的全局变量和函数时，只需包含模块A的头文件即可。这样，模块B中调用模块A中的函数时，在编译阶段，模块B虽然找不到该函数，但是并不会报错;它会在连接阶段中从模块A编译生成的目标代码中找到此函数。
​	其次，被它修饰的目标是“C”的，意思是其修饰的变量和函数是按照C语言方式编译和连接的。我们来看看C++中对类似C的函数是怎样编译的。作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如下面两个函数:



【答案】
代码第1、2、10行的作用是防止该头文件被重复引用。
代码第3行的作用是表示当前使用的是C++编译器。
代码第4~8行中的extern "C"是C++编译器提供的与C连接交换指定的符号，用来解决名字匹配问题。



# 11. #include <head.h>和#include "head.h"有什么区别

​	尖括号<>表明这个文件是一个工程或标准头文件。查找过程会首先检查预定义的目录，我们可以通过设置搜索路径环境变量或命令行选项来修改这些目录。
​	如果文件名用一对引号括起来，则表明该文件是用户提供的头文件，查找该文件时将从当前文件目录(或文件名指定的其他目录）中寻找文件，然后在标准位置寻找文件。



# 12. C++中main函数执行完后还执行其他语句吗?

考点: atexit()函数的使用

出现频率:★★★★【解析】

​	很多时候，我们需要在程序退出的时候做一些诸如释放资源的操作，但程序退出的方式有很多种，例如main()函数运行结束，在程序的某个地方用 exit()结束程序，用户通过Ctrl+C等操作发信号来终止程序，等等，因此需要有一种与程序退出方式无关的方法来进行程序退出时的必要处理。方法就是用atexit()函数来注册程序正常终止时要被调用的函数。

​	atexit()函数的参数是一个函数指针，函数指针指向一个没有参数也没有返回值的函数。atexit()的函数原型是:
```cpp
int atexit (void(* ) (void) ) ;
```


​	在一个程序中最多可以用atexit()注册32个处理函数，这些处理函数的调用顺序与其注册的顺序相反，即最先注册的最后调用，最后注册的最先调用。请看下面的程序代码。



【答案】
	可以用atexit()函数来注册程序正常终止时要被调用的函数，并且在main()函数结束时,调用这些函数的顺序与注册它们的顺序相反。